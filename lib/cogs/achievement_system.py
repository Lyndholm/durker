from datetime import datetime
from random import choice
from typing import Optional

from discord import Color, Embed
from discord.ext.commands import Cog, command, guild_only
from discord.ext.menus import ListPageSource, MenuPages
from loguru import logger

from ..db import db
from ..utils.lazy_paginator import paginate
from ..utils.utils import load_commands_from_json

cmd = load_commands_from_json('achievement_system')


class AchievementMenu(ListPageSource):
    def __init__(self, ctx, data, overview_type):
        self.ctx = ctx
        self.overview_type = overview_type
        self.thumbnails = (
            'https://school25.edu.yar.ru/dlya_stranits/trophy_icon_by_papillonstudio_d9dtwte_w394_h394.png',
            'https://icon-library.com/images/achievements-icon/achievements-icon-8.jpg',
            'https://cdn.iconscout.com/icon/free/png-512/achievement-1589036-1347675.png',
            'https://cdn4.iconfinder.com/data/icons/gamification-1/256/--02-512.png',
            'https://img.icons8.com/cotton/2x/sport-badge.png'
            )

        super().__init__(data, per_page=5)

    async def write_page(self, menu, offset, fields=[]):
        len_data = len(self.entries)

        embed = Embed(color=self.ctx.author.color).set_thumbnail(url=(self.thumbnails))
        embed.set_footer(text=f'{offset} ‚Äî {min(len_data, offset+self.per_page-1)} –∏–∑ {len_data} –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π'
                              f' | {self.ctx.prefix}getinfo <achievement> –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏')
        if self.overview_type == 'global':
            embed.title = 'üéñÔ∏è –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π'
        elif self.overview_type == 'user':
            embed.title = f'üéñÔ∏è –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è {self.ctx.author.display_name}'

        for name, value, in fields:
            embed.add_field(name=name, value=value, inline=False)

        return embed

    async def format_page(self, menu, entries):
        offset = (menu.current_page*self.per_page) + 1
        fields = []
        table = ('\n'.join(f'\n> **{entry[2]}**\n> **–û–ø–∏—Å–∞–Ω–∏–µ:** {entry[3]}'
                for idx, entry in enumerate(entries)))

        if self.overview_type == 'global':
            fields.append(('–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è:', table))
        elif self.overview_type == 'user':
            fields.append(('–û—Ç–∫—Ä—ã—Ç—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:', table))

        return await self.write_page(menu, offset, fields)


class AchievementSystem(Cog, name='–°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π'):
    def __init__(self, bot):
        self.bot = bot

    def chuncks(self, l, n):
        """Yield successive n-sized chunks from l."""
        for i in range(0, len(l), n):
            yield l[i:i + n]

    def can_view_hidden_achievement(self, ctx, internal_id: str):
        if ctx.author.id == self.bot.owner_ids[0]:
            return True

        rec = db.fetchone(['achievements_list'], 'users_stats', 'user_id', ctx.author.id)
        data = rec[0]['user_achievements_list']
        user_achievements = [key for dic in data for key in dic.keys()]
        return internal_id in user_achievements

    def advanced_achievements_memu(self, ctx, data):
        achievements = []

        for ach_chunks in list(self.chuncks(data, 1)):
            ach_chunks = ach_chunks[0]
            embed = Embed(
                title=f'üéñÔ∏è –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {ach_chunks[2]}',
                color=ctx.author.color,
                description=ach_chunks[3]
            ).set_thumbnail(url=ach_chunks[4])
            fields = [
                ('–ë—É—Å—Ç —Ä–µ–ø—É—Ç–∞—Ü–∏–∏', ach_chunks[6], True),
                ('–í—ã–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏', '–î–∞' if ach_chunks[7] else '–ù–µ—Ç', True),
                ('–ü–µ—Ä–≤–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ', ach_chunks[5], True)
            ]

            for name, value, inline in fields:
                embed.add_field(name=name, value=value, inline=inline)
            achievements.append(embed)

        for idx, embed in enumerate(achievements, 1):
            embed.set_footer(text=f'–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ ‚Ññ{idx} –∏–∑ {len(achievements)}')

        return achievements

    def achievement_helper(self, ctx, data):
        embed = Embed(
           title=f'üéñÔ∏è –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {data[2]}',
           color=ctx.author.color,
           description=data[3]
        ).set_thumbnail(url=data[4])
        fields = [
                ('–ë—É—Å—Ç —Ä–µ–ø—É—Ç–∞—Ü–∏–∏', data[6], True),
                ('–í—ã–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏', "–î–∞" if data[7] else "–ù–µ—Ç", True),
                ('–ü–µ—Ä–≤–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ', data[5], True)
            ]
        if ctx.author.id == self.bot.owner_ids[0]:
            fields.extend([
                ('id', data[0], True),
                ('internal_id', data[1], True),
                ('hidden', data[8], True),
            ])
        for name, value, inline in fields:
            embed.add_field(name=name, value=value, inline=inline)

        return [embed]


    @command(name=cmd["achieve"]["name"], aliases=cmd["achieve"]["aliases"],
            brief=cmd["achieve"]["brief"],
            description=cmd["achieve"]["description"],
            usage=cmd["achieve"]["usage"],
            help=cmd["achieve"]["help"],
            hidden=cmd["achieve"]["hidden"], enabled=True)
    @guild_only()
    @logger.catch
    async def how_achievement_sys_works_command(self, ctx):
        embed = Embed(
            title='üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: —á—Ç–æ —ç—Ç–æ, –¥–ª—è —á–µ–≥–æ –Ω—É–∂–Ω—ã, –∫–∞–∫ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å.',
            color=ctx.author.color,
            timestamp=datetime.utcnow()
        ).set_thumbnail(url='https://i.pinimg.com/originals/88/40/b8/8840b8d2c07bf805cdab22c0e4b54f59.gif')
        embed.set_footer(text=ctx.author, icon_url=ctx.author.avatar_url)
        embed.description = \
        '–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π.\n–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è ' \
        '‚Äî –æ–¥–∏–Ω –∏–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –∑–∞—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏. –£ –∫–∞–∂–¥–æ–π –∞—á–∏–≤–∫–∏ ' \
        '–µ—Å—Ç—å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏ –±–æ–Ω—É—Å–Ω—ã–µ –æ—á–∫–∏ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏, ' \
        '–∫–æ—Ç–æ—Ä—ã–µ –¥–∞—é—Ç—Å—è –∑–∞ –æ—Ç–∫—Ä—ã—Ç–∏–µ —ç—Ç–æ–π —Å–∞–º–æ–π –∞—á–∏–≤–∫–∏. –ë**–æ**–ª—å—à–∞—è —á–∞—Å—Ç—å ' \
        '–¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –≤—ã–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –Ω–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∞—á–∏–≤–∫–∏ –º–æ–≥—É—Ç –≤—ã–¥–∞—Ç—å ' \
        '—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã —Å–µ–≤—Ä–µ—Ä–∞. –°–æ —Å–ø–∏—Å–∫–æ–º –≤—Å–µ—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –º–æ–∂–Ω–æ ' \
        '–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è –≤ –∫–∞–Ω–∞–ª–µ <#604621910386671616> –ø–æ –∫–æ–º–∞–Ω–¥–µ ' \
        f'`{ctx.prefix}achievements`\n–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –ø–æ–ø–æ–ª–Ω—è–µ—Ç—Å—è. ' \
        '–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—é –Ω–æ–≤–æ–π –∞—á–∏–≤–∫–∏, –Ω–∞–ø–∏—à–∏—Ç–µ –æ–± ' \
        '—ç—Ç–æ–º –≤ –∫–∞–Ω–∞–ª–µ <#639925210849476608>\n–í —Å–ª—É—á–∞–µ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏—è ' \
        '–∫–∞–∫–∏—Ö-–ª–∏–±–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤—ã –º–æ–∂–µ—Ç–µ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ <@375722626636578816>'
        await ctx.reply(embed=embed, mention_author=False)


    @command(name=cmd["achievements"]["name"], aliases=cmd["achievements"]["aliases"],
            brief=cmd["achievements"]["brief"],
            description=cmd["achievements"]["description"],
            usage=cmd["achievements"]["usage"],
            help=cmd["achievements"]["help"],
            hidden=cmd["achievements"]["hidden"], enabled=True)
    @guild_only()
    @logger.catch
    async def achievements_list_command(self, ctx):
        data = db.records('SELECT * FROM achievements')
        if ctx.author.id != self.bot.owner_ids[0]:
            data = [i for i in data if i[8] is False]

        reactions = ['1Ô∏è‚É£', '2Ô∏è‚É£']
        embed = Embed(
            title='üí† –í—ã–±–æ—Ä –º–µ—Ç–æ–¥–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è',
            color=ctx.author.color,
            timestamp=datetime.utcnow(),
            description='**–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π:\n\n'
                        '1Ô∏è‚É£ ‚Äî –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è. 1 —Å—Ç—Ä–∞–Ω–∏—Ü–∞ = 1 –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ.\n'
                        '2Ô∏è‚É£ ‚Äî –∫—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞ –ø–æ –∫–∞–∂–¥–æ–º—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—é. 1 —Å—Ç—Ä–∞–Ω–∏—Ü–∞ = 5 –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π.**'
        )
        message = await ctx.reply(embed=embed, mention_author=False)
        for r in reactions:
            await message.add_reaction(r)
        try:
            method, user = await self.bot.wait_for(
                'reaction_add', timeout=120.0,
                check=lambda method, user: user == ctx.author
                and method.message.channel == ctx.channel
                and method.emoji in reactions)
        except TimeoutError:
            await message.clear_reactions()
            return
        await message.delete()
        method = "detailed" if str(method.emoji) == '1Ô∏è‚É£' else "briefly"

        if method == 'detailed':
            embed = self.advanced_achievements_memu(ctx, data)
            await paginate(ctx, embed)
        else:
            menu = MenuPages(
                source=AchievementMenu(ctx, data, 'global'),
                clear_reactions_after=True,
                timeout=120.0)
            await menu.start(ctx)


    @command(name=cmd["getinfo"]["name"], aliases=cmd["getinfo"]["aliases"],
            brief=cmd["getinfo"]["brief"],
            description=cmd["getinfo"]["description"],
            usage=cmd["getinfo"]["usage"],
            help=cmd["getinfo"]["help"],
            hidden=cmd["getinfo"]["hidden"], enabled=True)
    @guild_only()
    @logger.catch
    async def get_achievement_command(self, ctx, *, achievement: Optional[str]):
        if achievement:
            internal_id = db.field(
                "SELECT internal_id FROM achievements WHERE "
                "to_tsvector(name) @@ to_tsquery(''%s'')",
                achievement)

            if internal_id is not None:
                data = db.records(
                   'SELECT * FROM achievements WHERE internal_id '
                   'LIKE %s', internal_id
                )[0]
                if data[8] is False:
                    await paginate(ctx, self.achievement_helper(ctx, data))
                else:
                    if self.can_view_hidden_achievement(ctx, internal_id):
                        await paginate(ctx, self.achievement_helper(ctx, data))
                    else:
                        await ctx.reply('üïµÔ∏è –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Å–∫—Ä—ã—Ç–æ.', mention_author=False)
            else:

                await ctx.reply('4Ô∏è‚É£0Ô∏è‚É£4Ô∏è‚É£ –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.', mention_author=False)
        else:
            await ctx.reply('üìí –£–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è.', mention_author=False)

    @Cog.listener()
    async def on_ready(self):
        if not self.bot.ready:
           self.bot.cogs_ready.ready_up("achievement_system")


def setup(bot):
    bot.add_cog(AchievementSystem(bot))
